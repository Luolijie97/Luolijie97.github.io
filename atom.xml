<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://luolijie97.github.io/</id>
    <title>llj的blog</title>
    <updated>2020-03-18T10:06:10.866Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://luolijie97.github.io/"/>
    <link rel="self" href="https://luolijie97.github.io/atom.xml"/>
    <subtitle>llj&apos;s blog</subtitle>
    <logo>https://luolijie97.github.io/images/avatar.png</logo>
    <icon>https://luolijie97.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, llj的blog</rights>
    <entry>
        <title type="html"><![CDATA[AudioQueue音频队列录音使用]]></title>
        <id>https://luolijie97.github.io/post/audioqueue-yin-pin-dui-lie-lu-yin-shi-yong</id>
        <link href="https://luolijie97.github.io/post/audioqueue-yin-pin-dui-lie-lu-yin-shi-yong">
        </link>
        <updated>2020-03-18T10:00:25.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p>上篇介绍了AudioQueue录音的相关原理，这篇为有关实现。相关代码如下：</p>
<pre><code class="language-swift">//  AudioQueueRecorder.swift
import Foundation
import AudioToolbox
import AVFoundation

/// 录音队列回调函数
/// - Parameters:
///   - inUserData: 一个自定义结构，包含音频队列的状态数据
///   - inAQ: 调用回调函数的音频队列
///   - inBuffer: 包含音频数据的音频队列缓冲区
///   - inStartTime: 当前音频数据的时间戳，用于同步
///   - inNumberPacketDescription: inPacketDescs参数中的数据包描述的数量。录制VBR（动态比特率）格式时音频队列会提供该参数值，CBR（固定比特率）格式时值为0
///   - inPacketDescs: 音频数据中一组包的描述，录制VBR格式数据时需要将值传递给AudioFileWritePackets函数
func AQAudioQueueInputCallback(inUserData: UnsafeMutableRawPointer?,
                               inAQ: AudioQueueRef,
                               inBuffer: AudioQueueBufferRef,
                               inStartTime: UnsafePointer&lt;AudioTimeStamp&gt;,
                               inNumberPacketDescription: UInt32,
                               inPacketDescs: UnsafePointer&lt;AudioStreamPacketDescription&gt;?) {
    //转换为指定类型
    let audioService = unsafeBitCast(inUserData!, to:AudioService.self)
    audioService.writePackets(inBuffer: inBuffer)
    AudioQueueEnqueueBuffer(inAQ, inBuffer, 0, nil);
    
    print(&quot;startingPacketCount: \(audioService.startingPacketCount), maxPacketCount: \(audioService.maxPacketCount)&quot;)
    if (audioService.maxPacketCount &lt;= audioService.startingPacketCount) {
//        audioService.stopRecord()
        NotificationCenter.default.post(name: .init(rawValue: &quot;stopRecord&quot;), object: nil, userInfo: nil)
    }
}

class AudioService {
    /// 队列的buffer个数
    let kNumberBuffers: Int = 3
    var buffer: UnsafeMutableRawPointer
    var audioQueueObject: AudioQueueRef?
    /// 记录音频数据的文件的音频文件对象
    public var mAudioFile: AudioFileID?
    /// 初始packet数量
    var startingPacketCount: UInt32
    let bytesPerPacket: UInt32 = 2
    /// 每个音频队列缓冲区的大小(以字节为单位)
    var bufferByteSize: UInt32 = 0
    /// 录音最大时长
    let maxSeconds: UInt32 = 10
    /// 每次回调时长,单位秒
    let second: UInt32 = 3
    /// 每次回调所需写入的packet的数量 = 采样频率 * 每次回调时长
    let numPacketsToWrite: UInt32
    /// 当前录音的最大写入packet数量 = 采样频率 * 录音最大时长
    var maxPacketCount: UInt32
    /// 录音采样频率
    let sampleRate = 44100.0
    /// 音频格式
    var audioFormat: AudioStreamBasicDescription {
        return AudioStreamBasicDescription(mSampleRate: sampleRate,
                                           mFormatID: kAudioFormatLinearPCM,
                                           mFormatFlags: AudioFormatFlags(kLinearPCMFormatFlagIsSignedInteger | kLinearPCMFormatFlagIsPacked),
                                           mBytesPerPacket: 2,
                                           mFramesPerPacket: 1,
                                           mBytesPerFrame: 2,
                                           mChannelsPerFrame: 1,
                                           mBitsPerChannel: 16,
                                           mReserved: 0)
    }
    /// 录音开始标志
    var isRecording:Bool = false

    init() {
        startingPacketCount = 0
        numPacketsToWrite = UInt32(sampleRate) * second
        maxPacketCount = (UInt32(sampleRate) * maxSeconds)
        buffer = UnsafeMutableRawPointer(malloc(Int(maxPacketCount * bytesPerPacket)))
        
        print(&quot;startRecord&quot;)
        guard audioQueueObject == nil else  { return }
        prepareForRecord()
    }

    deinit {
        buffer.deallocate()
    }

    func startRecord() {
//        print(&quot;startRecord&quot;)
//        guard audioQueueObject == nil else  { return }
//        prepareForRecord()
        let err: OSStatus = AudioQueueStart(audioQueueObject!, nil)
        print(&quot;err: \(err)&quot;)
    }

    func stopRecord() {
        AudioQueueStop(audioQueueObject!, true)
        AudioQueueDispose(audioQueueObject!, true)
        audioQueueObject = nil
    }
    

    private func prepareForRecord() {
        print(&quot;prepareForRecord&quot;)
        var audioFormat = self.audioFormat
    
        //创建一个录音队列
        if AudioQueueNewInput(&amp;audioFormat,
                              AQAudioQueueInputCallback,
                              unsafeBitCast(self, to: UnsafeMutableRawPointer.self),
                              CFRunLoopGetCurrent(),
                              CFRunLoopMode.commonModes.rawValue,
                              0,
                              &amp;audioQueueObject) == noErr {
            print(&quot;录音队列创建成功!&quot;)
        } else {
            print(&quot;录音队列创建失败!!&quot;)
            return
        }
        
        // 获取设置的音频流格式
        var dataFormatSize: UInt32 = UInt32(MemoryLayout&lt;AudioStreamBasicDescription&gt;.size)
        //用以下方法验证获取到音频格式是否与我们设置的相符
        if AudioQueueGetProperty(audioQueueObject!, kAudioQueueProperty_StreamDescription, &amp;audioFormat, &amp;dataFormatSize) == noErr {
            print(&quot;音频流格式设置成功!&quot;)
        } else {
            print(&quot;音频流格式设置失败!!&quot;)
            return
        }
        
        // 创建音频文件路径
        let fileManager = FileManager()
        let filePath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).first?.appending(&quot;/record.caf&quot;)
        if !fileManager.fileExists(atPath: filePath!) {
            fileManager.createFile(atPath: filePath!, contents: nil, attributes: nil)
        }
        let outputURL = URL(fileURLWithPath: filePath!)
        // 创建音频文件
        if AudioFileCreateWithURL(outputURL as CFURL, kAudioFileCAFType, &amp;audioFormat, .eraseFile, &amp;mAudioFile) == noErr {
            print(&quot;创建音频文件成功！&quot;)
            print(&quot;音频文件URL: &quot;, outputURL)
        } else {
            print(&quot;创建音频文件失败!！&quot;)
            return
        }
        
        
        startingPacketCount = 0;
        var buffers = Array&lt;AudioQueueBufferRef?&gt;(repeating: nil, count: kNumberBuffers)
        /// 计算Audio Queue中每个buffer的大小
        bufferByteSize = numPacketsToWrite * audioFormat.mBytesPerPacket
        // 内存分配,入队
        for bufferIndex in 0 ..&lt; buffers.count {
            AudioQueueAllocateBuffer(audioQueueObject!, bufferByteSize, &amp;buffers[bufferIndex])
            AudioQueueEnqueueBuffer(audioQueueObject!, buffers[bufferIndex]!, 0, nil)
        }
        
        
    }
    
    func writePackets(inBuffer: AudioQueueBufferRef) {
        print(&quot;writePackets&quot;)
        //缓冲区中数据的总字节数除以每个数据包的(常数)字节数
        var numPackets: UInt32 = (inBuffer.pointee.mAudioDataByteSize / bytesPerPacket)
        if ((maxPacketCount - startingPacketCount) &lt; numPackets) {
            numPackets = (maxPacketCount - startingPacketCount)
        }
        print(&quot;writePackets mAudioDataByteSize: \(inBuffer.pointee.mAudioDataByteSize), numPackets: \(numPackets)&quot;)
        
        if 0 &lt; numPackets {
            //将当前buffer添到总的buffer中
            memcpy(buffer.advanced(by: Int(bytesPerPacket * startingPacketCount)),
                   inBuffer.pointee.mAudioData,
                   Int(bytesPerPacket * numPackets))
           
            
            //将缓冲区的内容写入音频数据文件
            if AudioFileWritePackets(mAudioFile!,
                                     false,
                                     bufferByteSize,
                                     nil,
                                     Int64(startingPacketCount),
                                     &amp;numPackets,
                                     inBuffer.pointee.mAudioData) == noErr {
                print(&quot;当前缓冲区已写入！&quot;)
            } else {
                print(&quot;写入失败！！&quot;)
            }
             startingPacketCount += numPackets
        }
        
    }
}

</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AudioQueue分片录音原理]]></title>
        <id>https://luolijie97.github.io/post/audioqueue-fen-pian-lu-yin-yuan-li</id>
        <link href="https://luolijie97.github.io/post/audioqueue-fen-pian-lu-yin-yuan-li">
        </link>
        <updated>2020-03-18T09:31:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基本原理介绍">基本原理介绍</h2>
<ul>
<li>要在 <code>iOS</code> 设备上录制音频，苹果推荐我们使用 <code>AVFoundation</code> 框架中的 <code>AVAudioRecorder</code> 类。虽然用法比较简单，但是不支持流式；这就意味着在录音时，必须等到录音结束后，才能获取到录音数据。这给应用造成了很大的局限性。为了解决这个问题，我们就需要使用 <code>Audio Queue Services</code> 来录制音频。</li>
</ul>
<h2 id="工作原理">工作原理</h2>
<img src="https://developer.apple.com/library/archive/documentation/MusicAudio/Conceptual/AudioQueueProgrammingGuide/Art/recording_callback_function_2x.png" alt="Illustration of the recording process when using an audio queue" style="zoom:33%;" />
<ul>
<li>音频的输入分为上图所示几个步骤：
<ul>
<li>步骤1，开始录音。将音频填入第一个缓冲区中</li>
<li>步骤2中，第一个缓冲区已被填满，此时音频队列将进行回调，并将填满的缓冲区（缓冲区1）传递给回调函数。同时，音频队列将新获得的数据填充另一个缓冲区（缓冲区2）</li>
<li>在回调函数中需要将音频数据流进行相关操作（写入磁盘）</li>
<li>在步骤4中，音频队列会将刚刚写入磁盘的缓冲区(buffer 1)重新放入缓冲队列，音频队列再次调用回调(步骤5) ，并将填满的缓冲区（缓冲区2）传递给回调函数，再将这个缓冲区的内容写入音频文件(步骤6)</li>
<li>上述循环将一直持续到用户停止录音为止</li>
</ul>
</li>
</ul>
<h2 id="具体操作">具体操作</h2>
<hr>
<h3 id="1-设置音频格式">1、设置音频格式</h3>
<ul>
<li>设置音频的采样率mSampleRate、PCM流格式mFormatID、标签格式mFormatFlags、声道数mChannelsPerFrame、每个数据包的字节数mBytesPerPacket、每个数据包的帧数mFramesPerPacket、每帧的字节数mBytesPerFrame、语言的采样点数mBitsPerChannel、保留位mReserved</li>
</ul>
<h3 id="2-初始化并为audio-queue分配内存">2、初始化并为Audio Queue分配内存</h3>
<ul>
<li>创建音频输入队列AudioQueueNewInput，指定回调函数AQAudioQueueInputCallback</li>
<li>创建缓冲器：分配内存AudioQueueAllocateBuffer，入队AudioQueueEnqueueBuffer</li>
<li>创建内存空间buffer：用于存放完整录音的数据</li>
</ul>
<h3 id="3-启动audio-queue开始录音">3、启动Audio Queue，开始录音</h3>
<ul>
<li>AudioQueueStart启动录制</li>
</ul>
<h3 id="4-回调函数中接收音频数据">4、回调函数中接收音频数据</h3>
<pre><code class="language-swift">func AQAudioQueueInputCallback(inUserData: UnsafeMutableRawPointer?,
                               inAQ: AudioQueueRef,
                               inBuffer: AudioQueueBufferRef,
                               inStartTime: UnsafePointer&lt;AudioTimeStamp&gt;,
                               inNumberPacketDescriptions: UInt32,
                               inPacketDescs: UnsafePointer&lt;AudioStreamPacketDescription&gt;?) {}
</code></pre>
<ul>
<li>在回调函数AQAudioQueueInputCallback中，inBuffer即为每次填满 Audio Queue产生的音频数据，每次都将当前分片数据加入buffer中</li>
<li>我们将拿到的inbuffer转换成swift中的NSData数据，并拼接上44字节的WAV格式的头部，即可得到当前分片的wav音频。</li>
</ul>
<h3 id="5-使用alamofiire将音频传给服务器">5、使用Alamofiire将音频传给服务器</h3>
<ul>
<li>实际项目中可根据需要，结合Alamofire实现客户端与服务器之前的音频分片传输。在回调函数<strong>AQAudioQueueInputCallback</strong>中，我们可以拿到回调的音频流<strong>inBuffer</strong>。</li>
</ul>
<h3 id="6-停止录音">6、停止录音</h3>
<ul>
<li>停止录音队列AudioQueueStop</li>
<li>移除缓冲区AudioQueueDispose</li>
<li>将完整的音频buffer数据转成NSData数据，用于处理当音频传输给服务器时errorCode=1的情况</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Accelerate框架之vDSP库的基础使用]]></title>
        <id>https://luolijie97.github.io/post/accelerate-kuang-jia-zhi-vdsp-ku-de-ji-chu-shi-yong</id>
        <link href="https://luolijie97.github.io/post/accelerate-kuang-jia-zhi-vdsp-ku-de-ji-chu-shi-yong">
        </link>
        <updated>2020-01-27T04:59:28.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在实际项目中，我需要将使用C语言编写的音高提取算法转成swift playground中能运行的swift版本，在其中要改写fft变换等C语言中需要进行上万次循环的代码。最开始我采用了最简单粗暴的方法进行直接改写，虽然能得到正确的结果，但实际性能上完全无法达到要求。在查阅有关资料后，发现Accelerate框架正是Swift中用来进行大量数学和图像计算的工具，但网络上相关中文文档总结几乎没有深入介绍，现根据我对developer documentation和stackflow上的相关提问，对项目中使用到的vDSP库进行小结</p>
</blockquote>
<h3 id="引用原因">引用原因</h3>
<ul>
<li>我们以向量运算为例展开说明：</li>
</ul>
<blockquote>
<pre><code class="language-swift">    let a: [Float] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    let b: [Float] = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
    let c: Float = 2
    var d = [Float](repeating: .nan, count: a.count)

    var startTime = CFAbsoluteTimeGetCurrent()
    //(a[i]+b[i])*(a[i]-b[i])
    for i in 0..&lt;a.count {
        d[i] = (a[i] + b[i]) * (a[i] - b[i])
    }
    print(d)
    var endTime = CFAbsoluteTimeGetCurrent()
    print(&quot;caculate: \((endTime - startTime) * 1000) ms&quot;) 
		//caculate: 0.32007694244384766 ms

    startTime = CFAbsoluteTimeGetCurrent()
    //(a[i]+b[i])*(a[i]-b[i])
    d = vDSP.multiply(addition: (a, b), subtraction: (a, b))//(a[i]+b[i])*(a[i]-b[i])
    print(d)
    endTime = CFAbsoluteTimeGetCurrent()
    print(&quot;caculate: \((endTime - startTime) * 1000) ms&quot;)
		//caculate: 0.09799003601074219 ms
</code></pre>
<ul>
<li>这里我们取了长度为10的数组进行了加减乘运算，从运行时间看，后者只用了1/3的时间。当向量长度较大时，比如几千、甚至上万时，vDSP库进行数组运算的效率提升就更为明显了，尤其是在代码中需要多层循环进行计算时。经测试，平均每层循环采用vDSP库中的函数可提高8-10的速度</li>
</ul>
</blockquote>
<h3 id="vdsp库介绍">vDSP库介绍</h3>
<p>vDSP框架包含用于数字信号处理和大型阵列的通用算法的高度优化的功能的集合</p>
<h3 id="向量基本运算">向量基本运算</h3>
<ul>
<li>
<p>旧API</p>
<blockquote>
<pre><code class="language-swift">let stride = vDSP_Stride(1) //确定运算处理的跨度，1代表对每一个元素进行操作
let a:[Float] = [2, 4, 3, 4, 5]
let b:[Float] = [35, 21, 62, 54, 45]
let len = vDSP_Length(a.count) //操作元素的数量
var c = [Float](repeating: 0, count: a.count)//存放操作结果
var d = [Float](repeating: 0, count: a.count)//存放操作结果

//二元运算
vDSP_vadd(a, stride, b, stride, &amp;c, stride, len) //加法运算
print(c) // [37.0, 25.0, 65.0, 58.0, 50.0]

vDSP_vsub(a, stride, b, stride, &amp;c, stride, len) //减法运算b-a
print(c) // [33.0, 17.0, 59.0, 50.0, 40.0]

//以上两句可合成一句
vDSP_vaddsub(a, stride, b, stride, &amp;c, stride, &amp;d, stride, len)
print(&quot;add: &quot;, c) //add:  [37.0, 25.0, 65.0, 58.0, 50.0]
print(&quot;sub: &quot;, d) //sub:  [33.0, 17.0, 59.0, 50.0, 40.0]

vDSP_vmul(a, stride, b, stride, &amp;c, stride, len) //乘法运算
print(c) //[70.0, 84.0, 186.0, 216.0, 225.0]

vDSP_vdiv(a, stride, b, stride, &amp;c, stride, len) //除法运算b/a
print(c) //[17.499998, 5.2499995, 20.666666, 13.499999, 8.999999]

//三元运算
let m:[Float] = [3, 4, 5, 6, 7]

vDSP_vam(a, stride, b, stride, m, stride, &amp;c, stride, len) //c = (a+b)*m
print(c) //[111.0, 100.0, 325.0, 348.0, 350.0]

vDSP_vma(a, stride, b, stride, m, stride, &amp;c, stride, len) //c = a*b+m
print(c) //[73.0, 88.0, 191.0, 222.0, 232.0]

vDSP_vmsb(a, stride, b, stride, m, stride, &amp;c, stride, len) //c = a*b-m
print(c) //[67.0, 80.0, 181.0, 210.0, 218.0]

vDSP_vsbm(a, stride, b, stride, m, stride, &amp;c, stride, len) //c = (a-b)*c
print(c) //[-99.0, -68.0, -295.0, -300.0, -280.0]

//四元运算
let n:[Float] = [7, 6, 5, 4, 3]

vDSP_vsbsbm(a, stride, b, stride, m, stride, n, stride, &amp;c, stride, len) //c = (a-b)*(m-n)
print(c) //[132.0, 34.0, -0.0, -100.0, -160.0]

vDSP_vasbm(a, stride, b, stride, m, stride, n, stride, &amp;c, stride, len) //c = (a+b)*(m-n)
print(c) //[-148.0, -50.0, 0.0, 116.0, 200.0]
</code></pre>
</blockquote>
</li>
<li>
<p>新API</p>
<blockquote>
<pre><code class="language-swift"> let a: [Float] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 let b: [Float] = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
 let c: Float = 2
 var d = [Float](repeating: .nan, count: a.count)
 
 d = vDSP.add(a, b) //(a[i]+b[i])
 print(d)
 d = vDSP.add(5, a) //a[i]+5
 print(d)
 d = vDSP.add(multiplication: (a, b), 5) //a[i]*b[i]+5
 
 d = vDSP.subtract(a, b) //a[i]-b[i]
 print(d)
 d = vDSP.subtract(multiplication: (a, b), a)//a[i]*b[i]-a[i]
 print(d)
 
 d = vDSP.multiply(addition: (a, b), c) //(a[i]+b[i])*c[i]
 print(d)
 d = vDSP.multiply(addition: (a, b), subtraction: (a, b))//(a[i]+b[i])*(a[i]-b[i])
 print(d)
 
 
 d = vDSP.divide(a, b) //a[i]/b[i]
 print(d)
 
 print(vDSP.dot(a, b))//a[i]点乘b[i]
 print(vDSP.absolute(a))//abs(a[i])
 
 
 d = vDSP.ramp(withInitialValue: 0, increment: 1, count: a.count) //生成等差数列
 print(d)
 
 let source:[Float] = [23.0, 2.2, 1.1, 13.2]
 let result = vDSP.floatingPointToInteger(source, integerType: UInt16.self, rounding: .towardZero) //Float转UInt16
 print(result)
 let oriResult = vDSP.integerToFloatingPoint(result, floatingPointType: Float.self) //UInt16转Float
 print(oriResult)
 
 let array = [12.2, 23.3, 11.1, 34.3, 78.7, 89.8, 56.5, 23.2]
 let (id, maxResult) = vDSP.indexOfMaximum(array) //获取数组元素的最大值及其索引
 print(id, maxResult)
</code></pre>
</blockquote>
</li>
</ul>
<h3 id="stride和vdsp_length的使用">Stride和vDSP_Length的使用</h3>
<ul>
<li><code>针对向量的基本运算,新Api的调用参数更少，方法的使用更加符合swift语言的习惯，但需要对运算的操作对象有其他要求时，我们就需要使用旧Api的相关参数进行设置，而其中改变的便是步长Stride和运算次数vDSP_Length</code></li>
</ul>
<blockquote>
<ul>
<li><strong>引例</strong></li>
</ul>
<pre><code class="language-swift">    let a:[Float] = [10, 20, 30, 40, 50, 60, 70, 80]
    let b:[Float] = [1, 2, 3, 4, 5, 6, 7, 8]
    var n = vDSP_Length(a.count)
    var c = [Float](repeating: .nan, count: a.count)
    
    var strideA = vDSP_Stride(1)
    var strideB = vDSP_Stride(1)
    var strideC = vDSP_Stride(1)
    
    vDSP_vadd(a, strideA, b, strideB, &amp;c, strideC, n)
    print(c) //[11.0, 22.0, 33.0, 44.0, 55.0, 66.0, 77.0, 88.0]
</code></pre>
<ul>
<li>这里我们进行了向量a和向量b的和运算，将结果存放在向量c中。我们将a,b,c的Stride均设置为1，则表达式将会对a、b中每一个元素进行加法运算，将结果依次存放在c中的每个元素中，这里运算次数为a的元素个数，类型为vDSP_Length</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>改变输入的Stride</strong></li>
</ul>
<pre><code class="language-swift">    //改变输入的Stride
    strideB = vDSP_Stride(3)
    n = vDSP_Length(3) //运算次数
    c = [Float](repeating: .nan, count: a.count)
    vDSP_vadd(a, strideA, b, strideB, &amp;c, strideC, n)
    print(c) //[11.0, 24.0, 37.0, nan, nan, nan, nan, nan]
</code></pre>
<ul>
<li>我们将b的Stride设为3，运算次数n设为3，则b向量将取出第0、3、6三个位置的元素和a的第0、1、2三个位置的元素进行加法运算，结果保存在c的前三个元素中</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>改变输出的Stride</strong></li>
</ul>
<pre><code class="language-swift">    //改变输出的Stride
    strideA = vDSP_Stride(2)
    strideB = vDSP_Stride(1)
    strideC = vDSP_Stride(3)
    n = vDSP_Length(3)
    c = [Float](repeating: .nan, count: a.count)
    vDSP_vadd(a, strideA, b, strideB, &amp;c, strideC, n)
    print(c) //[11.0, nan, nan, 32.0, nan, nan, 53.0, nan]
</code></pre>
<ul>
<li>a、b、c的Stride分别为2、1、3，运算次数vDSP_Length为3。则将取出a的第0、2、4个位置处的元素，与b的0、1、2位置处的元素相加，结果存放在c的第0、3、6处的位置中</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>使用负Stride</strong></li>
</ul>
<pre><code class="language-swift">    //使用负Stride
    strideA = vDSP_Stride(-1)
    strideB = vDSP_Stride(1)
    strideC = vDSP_Stride(1)
    n = vDSP_Length(a.count)
    a.withUnsafeBufferPointer { (buffer) in
        vDSP_vadd(buffer.baseAddress! + buffer.count - 1, strideA, b, strideB, &amp;c, strideC, n)
    }
    print(c) //[81.0, 72.0, 63.0, 54.0, 45.0, 36.0, 27.0, 18.0]
</code></pre>
<ul>
<li>向量a的Stride为-1，这时每次运算都将依次取出当前指针所指元素的前一个位置进行运算。在这里，我们将指向向量a指针的初始位置移动到a中的最后一个元素，则每次运算中，a将倒序取出一个数，和b中顺序取出的一个数进行加法运算</li>
</ul>
</blockquote>
<h3 id="dspcomplex与dspsplitcomplex">DSPComplex与DSPSplitComplex</h3>
<ul>
<li>
<p>在实际数学运算中，我们的操作对象往往会涉及到复数域，而在vDSP库中，我们定义了四个结构体对复数进行存储：DSPComplex、DSPDoubleComplex、DSPSplitComplex和DSPDoubleSplitComplex。其中，DSPDoubleComplex、DSPDoubleSplitComplex与DSPComplex、DSPSplitComplex的区别仅在于运算精度的区别。前者为Double双精度，后者为Float单精度。在这里我们就以DSPComplex、DSPSplitComplex为例进行介绍</p>
</li>
<li>
<p>DSPComplex结构</p>
<pre><code class="language-swift">public struct DSPComplex {

    public var real: Float

    public var imag: Float

    public init()

    public init(real: Float, imag: Float)
}
</code></pre>
<ul>
<li>DSPComplex以有序对的形式存放了两个浮点类型的数，因而当做相关运算时，其步长Stride应为2的倍数</li>
</ul>
</li>
<li>
<p>DSPSplitComplex结构</p>
<pre><code class="language-swift">public struct DSPSplitComplex {

    public var realp: UnsafeMutablePointer&lt;Float&gt;

    public var imagp: UnsafeMutablePointer&lt;Float&gt;

    public init(realp: UnsafeMutablePointer&lt;Float&gt;, imagp: UnsafeMutablePointer&lt;Float&gt;)
}
</code></pre>
<ul>
<li>DSPSplitComplex中存放了两个UnsafeMutablePointer<Float>类型的数组，一个用来存放实数部分，另一个存放虚数部分。在做相关运算时，其步长Stride是连续的</li>
</ul>
</li>
<li>
<p>DSPComplex与DSPSplitComplex转化</p>
<pre><code class="language-swift">    var real:[Float] = [10, 20 ,30, 40, 50, 60, 70, 80]
    var imag:[Float] = [1, 2, 3, 4, 5, 6, 7, 8]
    let n = real.count
    let strideSplitComplex = vDSP_Stride(1)
    let strideComplex = vDSP_Stride(2)
    var complex = [DSPComplex](repeating: DSPComplex(), count: n)

    //初始化DSPSplitComplex
    var splitComplex = DSPSplitComplex(realp: &amp;real, imagp: &amp;imag)
    //DSPSplitComplex转DSPComplex
		vDSP_ztoc(&amp;splitComplex, strideSplitComplex, &amp;complex, strideComplex, vDSP_Length(n))
		//DSPComplex转DSPSplitComplex
		vDSP_ctoz(&amp;complex, strideComplex, &amp;splitComplex, strideSplitComplex, vDSP_Length(n))
</code></pre>
<ul>
<li>这里vDSP_ztoc和vDSP_ctoz方法分别为DSPSplitComplex转DSPComplex和DSPComplex转DSPSplitComplex。其中要注意DSPComplex的步长为2</li>
<li>这里我们也可以用新API进行简化：</li>
</ul>
<pre><code class="language-swift">    var real:[Float] = [10, 20 ,30, 40, 50, 60, 70, 80]
    var imag:[Float] = [1, 2, 3, 4, 5, 6, 7, 8]
  let n = real.count
    var complex = [DSPComplex](repeating: DSPComplex(), count: n)

		//初始化DSPSplitComplex
    var splitComplex = DSPSplitComplex(realp: &amp;real, imagp: &amp;imag)
 		//DSPSplitComplex转DSPComplex
    vDSP.convert(splitComplexVector: splitComplex, toInterleavedComplexVector: &amp;complex)
		//DSPComplex转DSPSplitComplex
    vDSP.convert(interleavedComplexVector: complex, toSplitComplexVector: &amp;splitComplex)
</code></pre>
</li>
</ul>
<h3 id="fft相关">FFT相关</h3>
<ul>
<li>
<p>vDSP库，顾名思义，是一个用来做数字信号处理的库，比如傅里叶变换、快速傅里叶变换等。在这里我们简单介绍下我在项目中用到的窗函数和FFT的使用</p>
</li>
<li>
<p>窗函数的使用（汉明窗为例）</p>
</li>
</ul>
<blockquote>
<pre><code class="language-swift"> //汉明窗函数
 let windowLength:Double = 2048.0
 var hammingWindow = [Float](repeating: .nan, count: Int(windowLength))
 vDSP_hamm_window(&amp;hammingWindow, vDSP_Length(windowLength), 0)
</code></pre>
<ul>
<li>这里我们创建了一个长度为2048的双边汉明窗</li>
</ul>
<pre><code class="language-swift">    //汉明窗函数
    let windowLength:Double = 2048.0
    //新API
    let hammingWindow = vDSP.window(ofType: Float.self, usingSequence: .hamming, count: Int(windowLength), isHalfWindow: false)
</code></pre>
<ul>
<li>这里我们使用了新api创建了汉明窗，结果和旧API一致。其中ofType参数确定汉明窗操作的精度，即返回的数组的类型；usingSequence为生成的窗函数序列类型，这里我们使用了汉明窗；count代表生成的序列长度；isHalfWindow值为false，代表生成全部长度的序列</li>
</ul>
</blockquote>
<ul>
<li>FFT：快速傅里叶变换</li>
</ul>
<blockquote>
<pre><code class="language-swift">		//FFT变换相关参数设置
 let log2Size = Int(log2(Float(fftLength)))
 let fftSetup = vDSP_create_fftsetup(vDSP_Length(log2Size), FFTRadix(kFFTRadix2))
 //变换的输入
 var complexBuffer = DSPSplitComplex(realp: &amp;realPart, imagp: &amp;imaginaryPart)
 //FFT变换
		//第一个参数是fft相关参数；第二个参数是一个inout类型数组，我们将变换的输入数组传入，变换结束后，返回结果也是该参数；第三个参数为FFT变换的长度，要取log2;第三个参数确定fft变换的方面，这里选取FFT_FORWARD前向传播
 vDSP_fft_zip(fftSetup!, &amp;complexBuffer, 1, vDSP_Length(log2Size), FFTDirection(FFT_FORWARD))
		//将fft变换结果取模，存放在fftResultNoPhase中（如果需要获取变换的幅值）
		vDSP_zvabs(&amp;complexBuffer, 1, &amp;fftResultNoPhase, 1, vDSP_Length(fftLength))
</code></pre>
<ul>
<li>我们也可以用新API简化：</li>
</ul>
<pre><code class="language-swift">    let log2Size = Int(log2(Float(fftLength)))
		//FFT变换相关参数设置
    let fwdFFT = vDSP.FFT(log2n: vDSP_Length(log2Size), radix: .radix2, ofType: DSPSplitComplex.self)!
		//FFT变换，输入输出为DSPSplitComplex类型
    fwdFFT.transform(input: input, output: &amp;output, direction: .forward)
		//变换结果取幅值，存放在fftResultNoPhase中
    vDSP.absolute(output, result: &amp;fftResultNoPhase)
</code></pre>
</blockquote>
<h3 id="小结">小结</h3>
<ul>
<li>vDSP包含用于大型阵列的通用算法的高度优化的功能的集合，可以用来进行复杂的数组运算。在不需要对操作数组的步长Stride和运算次数n进行定制时，我们可以用新API简化调用</li>
<li>vDSP有强大的信号处理功能，我们可以在Developer Documentation中查阅。这里我们简单介绍了窗函数和FFT变换的设置，更多功能请到官方文档查询。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift的几种界面传值方式]]></title>
        <id>https://luolijie97.github.io/post/swift-jiemianchuanzhi</id>
        <link href="https://luolijie97.github.io/post/swift-jiemianchuanzhi">
        </link>
        <updated>2020-01-19T04:57:12.000Z</updated>
        <content type="html"><![CDATA[<p>swift常用界面传值方式如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>单例</th>
<th>通知</th>
<th>代理</th>
<th>闭包</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>常用</td>
<td>常用</td>
<td>常用</td>
</tr>
</tbody>
</table>
<p>下面将使用<code>ViewController.swift</code>和<code>SecondViewController.swift</code>加以说明</p>
<h3 id="1属性传值">1.属性传值</h3>
<blockquote>
<pre><code class="language-swift">//属性传值：从ViewController跳转传值给SecondViewController

//SecondViewController.swift
class SecondViewController: UIViewController {
var textField: UITextField!
//属性传值
var tfStr: String!
}
override func viewDidLoad() {
super.viewDidLoad()
self.view.backgroundColor = .white
setupUI() //相关布局
//属性传值
textField.text = tfStr
}

//ViewController.swift
class ViewController: UIViewController {
fileprivate var textField: UITextField!
//按钮点击方法
@objc fileprivate func btnAction() {
 let svc = SecondviewController()
 //传值
 svc.tfStr = textField.text
 //跳转
 navigationController?.pushViewController(svc, animated: true)
}
}
</code></pre>
</blockquote>
<h3 id="2单例传值">2.单例传值</h3>
<blockquote>
<pre><code class="language-swift">//单例传值：从ViewController跳转传值给SecondViewController

//Singleton.swift
class Singleton {
//单例属性，用来传值
	var text: String!
static let singleton = Singleton()
//单例的实例方法
func share() -&gt; Singleton {
 return .singleton
}
}

//ViewController.swift
class ViewController: UIViewController {
fileprivate var textField: UITextField!
//按钮点击方法
@objc fileprivate func btnAction() {
 //传值
 let singleton = Singleton.singleton.share()
 singleton.text = textField.text
 //跳转
 navigationController?.pushViewController(svc, animated: true)
}
}

//SecondViewController.swift
class SecondViewController: UIViewController {
var textField: UITextField!
var tfStr: String!
override func viewDidLoad() {
 super.viewDidLoad()
 self.view.backgroundColor = .white
 setupUI()
 //单例传值
 tfStr = Singleton.singleton.share().text
 print(tfStr!)
 textField.text = tfStr
}
}

</code></pre>
</blockquote>
<h3 id="3通知传值">3.通知传值</h3>
<blockquote>
<pre><code class="language-swift">//通知传值：从SecondViewController跳转传值给ViewController

//SecondViewController.swift
class SecondViewController: UIViewController {
var textField: UITextField!
//按钮点击方法
@objc func btnAction() {
//通知传值：发送通知
NotificationCenter.default.post(name: NSNotification.Name(rawValue: &quot;notifyName&quot;), object: nil, userInfo: [&quot;text&quot;: self.textField.text ?? &quot;&quot;])
		//跳转
navigationController?.popViewController(animated: true)
}
}

//ViewController.swift
class ViewController: UIViewController {
fileprivate var textField: UITextField!
override func viewDidLoad() {
 super.viewDidLoad()
 self.view.backgroundColor = .white
 setupUI()
 //注册通知
 NotificationCenter.default.addObserver(forName: NSNotification.Name(rawValue: &quot;notifyName&quot;), object: nil, queue: .main) { (notification) in                                                                                                                       self.textField.text = &quot;\(notification.userInfo?[&quot;text&quot;] ?? &quot;&quot;)&quot;                                                                                                                         		}
}
//注销通知
deinit {
 NotificationCenter.default.removeObserver(self)
}
}


</code></pre>
</blockquote>
<h3 id="4代理传值">4.代理传值</h3>
<blockquote>
<pre><code class="language-swift">//代理传值：从SecondViewController跳转传值给ViewController

//SecondViewController.swift
//1.声明协议与方法
@objc protocol SecondViewControllerDelegate: class {
@objc optional func viewController(viewController: SecondViewController, popWith)
}

class SecondViewController: UIViewController {
//2.声明协议属性
weak var delegate: SecondVieControllerDelegate!
	var textField: UITextField!

@objc func btnAction() {
 //3.协议调用
 if let delegate = self.delegate {
   delegate.viewController?(viewController: self, popWithValue: self.textField.text ?? &quot;&quot;)
 }
}
}

//ViewController.swift
//4.遵守协议
class ViewController: UIViewController, SecondViewControllerDelegate {
fileprivate var textField: UITextField!

//5.设置代理
let svc = SecondViewController()
svc.delegate = self

//6.实现协议方法
//MARK: - SecondViewControllerDelegate
func viewController(viewController: SecondViewController, popWithValue: String) {
     textField.text = popWithValue
 }
}
</code></pre>
</blockquote>
<pre><code>### 5.闭包传值
</code></pre>
<blockquote>
<pre><code class="language-swift">//闭包传值：从SecondViewController跳转传值给ViewController

//SecondViewController.swift
class SecondViewController: UIViewController {
var textField: UITextField!

//1.声明闭包类型
typealias ClosureName = (String) -&gt; ()
//2.声明闭包属性
var closure: ClosureName!
//3.设置闭包传值调用方法
func callBack(closure: @escaping ClosureName) {
 self.closure = closure
}

@objc func btnAction() {
 //4.闭包回调
 guard (self.closure != nil) else {
   return
 }
 closure(textField.text!)
 
 navigationController?.popViewController(animated: true)
}
}

//ViewController.swift
class ViewController: UIViewController {
fileprivate var textField: UITextField!

@objc fileprivate func btnAction() {
 let svc = SecondViewController()
 //5.调用闭包方法
 svc.callBack { (value) in
     self.textField.text = value
 }
}
}
</code></pre>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift project in 30 days 学习笔记]]></title>
        <id>https://luolijie97.github.io/post/Swift project in 30 days 学习笔记</id>
        <link href="https://luolijie97.github.io/post/Swift project in 30 days 学习笔记">
        </link>
        <updated>2020-01-16T13:30:33.000Z</updated>
        <content type="html"><![CDATA[<h2 id="day1-customfont">day1: CustomFont</h2>
<ul>
<li>
<p><strong><em>SnapKit</em></strong> 第三方autolayout自动布局库</p>
<pre><code class="language-swift">let changeBtn = UIButton(type: .custom)
changeBtn.snp.makeConstraints { (make) in
//            make.top.equalTo(500)
    make.top.equalTo(label.snp.bottom).offset(300)
    make.centerX.equalTo(self.view)
    make.width.equalTo(200)
  }
</code></pre>
</li>
<li>
<p>UIFont.familyNames</p>
</li>
<li>
<p>UIfont.fontNames</p>
<pre><code class="language-swift">let familyNames = UIFont.familyNames
for familyName in familyNames {
  print(&quot;+++++ \(familyName)&quot;)
  let fontNames = UIFont.fontNames(forFamilyName: familyName)
  for fontName in fontNames {
    print(&quot;---- \(fontName)&quot;)
  }
}
</code></pre>
</li>
</ul>
<h2 id="day2-watchs-demo">day2: Watch's Demo</h2>
<ul>
<li>
<p>SnapKit</p>
<pre><code class="language-swift">let resetButton = UIButton()
resetButton.snp.makeConstraints { (make) in
   make.top.equalTo(10)
   make.right.equalTo(-10)
   make.width.equalTo(100)
   make.height.equalTo(50)
}
</code></pre>
</li>
<li>
<p>Timer使用</p>
</li>
<li>
<pre><code class="language-swift">var timer: Timer!
  @objc func startHander() {
      if self.timer != nil {
          self.stopHander()
      }
      self.timer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true, block: { (Timer) in
          self.labelNumber += 0.1
          self.result.text = String(format: &quot;%.1f&quot;, self.labelNumber)
      })
      self.timer.fire()
      
  }

  @objc func stopHander() {
      guard let timerForDistory = self.timer else { return }
      timerForDistory.invalidate()
  }
  
  @objc func resetHander() {
      self.labelNumber = 0
      self.result.text = &quot;0&quot;
  }
</code></pre>
</li>
<li></li>
</ul>
<h2 id="day3-find-my-position">day3: Find My Position</h2>
<ul>
<li>
<p>毛玻璃效果</p>
<ul>
<li>UIBlurEffect</li>
<li>UIVibrancyEffect：放大和调整 UIVisualEffectView 视图下面的内容的颜色
<ul>
<li><code>//创建并添加vibrancy视图 let vibrancyEffect = UIVibrancyEffect(blurEffect: blurEffect)</code></li>
</ul>
</li>
<li>UIVisualEffectView：模糊视图
<ul>
<li>//创建一个承载模糊效果的视图<br>
let blurView = UIVisualEffectView(effect: blurEffect)</li>
</ul>
</li>
</ul>
<pre><code class="language-swift">        let blurEffect = UIBlurEffect(style: .light)
        let blurView = UIVisualEffectView(effect: blurEffect)
        blurView.frame = self.view.bounds
        self.view.addSubview(blurView)
</code></pre>
</li>
<li>
<p>获取定位：CLLocationManger,CLLocationManagerDelegate</p>
<ul>
<li>
<pre><code class="language-swift">let locationManger = CLLocationManager()
let geocoder = CLGeocoder()

locationManger.delegate = self

let findMyLocationBtn = UIButton(type: .custom)
findMyLocationBtn.addTarget(self, action: #selector(findMyLocation), for: .touchUpInside)
self.view.addSubview(findMyLocationBtn)

//start find location
@objc func findMyLocation() {
  locationManger.requestAlwaysAuthorization()
  locationManger.startUpdatingLocation()
}
//CLLocationManagerDelegate
//Tells the delegate that new location data is available.
func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
  let locations: NSArray = locations as NSArray
  let currentLocation = locations.lastObject as! CLLocation
  let locationStr = &quot;lat:\(currentLocation.coordinate.latitude) lng:\(currentLocation.coordinate.longitude)&quot;

  locationLabel.text = locationStr
  reverseGeocode(location: currentLocation)
  locationManger.stopUpdatingLocation()
}
//将经纬度转换为城市名
func reverseGeocode(location: CLLocation) {
  geocoder.reverseGeocodeLocation(location) { (palceMark, error) in
     if (error == nil) {
         let tempArray = palceMark! as NSArray
         let mark = tempArray.firstObject as! CLPlacemark
         //now begins the reverse geocode
         let country = mark.country!
         let city = mark.locality!
         let street = mark.thoroughfare!

         let finalAddress = &quot;\(street),\(city),\(country)&quot;
         self.locationStrLabel.text = finalAddress

     }
  }
}
</code></pre>
</li>
<li></li>
</ul>
</li>
<li>
<p>缩略图: image literal, color literal</p>
</li>
</ul>
<h2 id="day4-limit-input-text-field">day4: Limit input Text Field</h2>
<ul>
<li>
<p>UINavigationController和UINavigationItem的使用</p>
<pre><code class="language-swift">let leftItem = UIBarButtonItem(title: &quot;close&quot;, style: .plain, target: self, action: nil)
self.navigationItem.leftBarButtonItem = leftItem
let rightItem = UIBarButtonItem(title: &quot;Tweet&quot;, style: .plain, target: self, action: nil)
rightItem.tintColor = .green
self.navigationItem.rightBarButtonItem = rightItem
self.window?.rootViewController = UINavigationController(rootViewController: ViewController())
</code></pre>
<ul>
<li><strong><code>ios13默认无UINavigationController</code></strong></li>
</ul>
</li>
<li>
<p>UITextViewDelegate使用</p>
<ul>
<li>通过UITextView的textViewDidChange委托事件捕捉当前输入内容</li>
<li>extViewDidBeginEditing 开始</li>
<li>textViewDidEndEditing 结束</li>
</ul>
</li>
<li>
<p><strong><code>通过监听UIResponder.keyboardWillChangeFrameNotification事件来监视Keyboard的弹出和收起</code></strong></p>
<ul>
<li>
<p><strong>Notification中的userinfo有键盘相关信息</strong></p>
</li>
<li>
<pre><code class="language-swift">//userinfo中包含keyboard相关信息
//获得键盘动画时长: note.userInfo?[UIResponder.keyboardAnimationDurationUserInfoKey] 
let duration = note.userInfo?[UIResponder.keyboardAnimationDurationUserInfoKey] as! TimeInterval
//获得键盘的endFrame: note.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] 
let endFrame = (note.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as! NSValue).cgRectValue
</code></pre>
</li>
</ul>
</li>
<li>
<p>ios动画实现之UIView</p>
<ul>
<li>UIView.animate(withDuration:) {}</li>
</ul>
</li>
</ul>
<h2 id="day5-pull-to-refresh">day5: Pull To Refresh</h2>
<ul>
<li>
<p><strong>UIRefreshControl</strong> 下拉刷新控件使用</p>
<pre><code class="language-swift">let refresh = UIRefreshControll()
refresh.attributedTitle = .init(string:&quot;Pulling&quot;)
refresh.addTarget(self, action: #selector(pullTheRefresh), for: .valueChanged)

@objc func pullTheRefresh() {
  //...
  refresh.endRefreshing()
  //...
}
</code></pre>
</li>
<li>
<p>下拉触发事件： <code>UIControl.Event.valueChanged</code></p>
</li>
<li>
<p>UITableView组件的使用</p>
<ul>
<li><strong><code>delegate &amp; datasource</code></strong></li>
<li>separateor 分割线</li>
</ul>
<pre><code class="language-swift">var table: UITableView!
table = UITableView(frame: self.view.bounds)
table.frame.origin.y = 44
table.separatorStyle = .singleLine
table.separatorColor = .black
self.view.addSubview(table)

table.delegate = self
table.dataSource = self
</code></pre>
</li>
<li>
<p><code>DateFormatter</code>日期转换</p>
<ul>
<li>.dataFormat 转换格式</li>
</ul>
<pre><code class="language-swift">let dateFormatter = DateFormatter()
dateFormatter.dateFormat = &quot;yyyy年MM月dd日/HH时mm分ss秒&quot;
let dateStr = dateFormatter.string(from: dataSource[indexPath.row])
</code></pre>
</li>
</ul>
<h2 id="day6-video-player">day6: Video Player</h2>
<ol>
<li>AVAudioPlayer 音频播放器实体
<ul>
<li>AVAudioSession.shareInstance() 音频相关设置</li>
</ul>
</li>
</ol>
<blockquote>
<pre><code class="language-swift">let audioPath = Bundle.main.path(forResource: &quot;live.mp3&quot;, ofType: nil)
let audioUrl = URL(fileURLWithPath: audioPath!)
//音频初始化
do {
audioPlayer = try AVAudioPlayer(contentsOf: audioUrl)
print(&quot;audioplayer is not nil&quot;)
} catch {
audioPlayer = nil

print(&quot;error:\(error)&quot;)
}
do {
//激活音频会话
try AVAudioSession.sharedInstance().setCategory(.playback)
try AVAudioSession.sharedInstance().setActive(true)
} catch {
print(&quot;error:\(error)&quot;)
}
</code></pre>
</blockquote>
<ol start="2">
<li>
<p>AVAudioPlayerDelegate 音频播放相关委托</p>
</li>
<li>
<p>后台播放相关设置（plist, code）</p>
</li>
</ol>
<blockquote>
<p><img src="https://raw.githubusercontent.com/Luolijie97/Pic_PicGo/master/img/image-20191110142700690.png" alt="" loading="lazy"><br>
<img src="https://raw.githubusercontent.com/Luolijie97/Pic_PicGo/master/img/image-20191110142743216.png" alt="" loading="lazy"></p>
</blockquote>
<ol>
<li>锁屏相关设置
<ul>
<li>MPNowPlayingInfoCenter.default().nowPlayingInfo 锁屏信息</li>
<li>remoteControlReceived 代理方法实现</li>
</ul>
</li>
</ol>
<blockquote>
<pre><code class="language-swift">func initForLockScreen() {

let artWorkImage:UIImage = UIImage(named: &quot;thumb.jpg&quot;)!

MPNowPlayingInfoCenter.default().nowPlayingInfo = [
 MPMediaItemPropertyTitle:&quot;皇后大道东&quot;,
 MPMediaItemPropertyArtist:&quot;罗大佑&quot;,
 MPMediaItemPropertyArtwork:MPMediaItemArtwork(boundsSize: artWorkImage.size, requestHandler: { (size) -&gt; UIImage in
                                                                                               return artWorkImage
                                                                                              }),
 MPNowPlayingInfoPropertyPlaybackRate:1.0,
 MPMediaItemPropertyPlaybackDuration:audioPlayer?.duration ?? 0,
 MPNowPlayingInfoPropertyElapsedPlaybackTime:audioPlayer?.currentTime ?? 0
]

if (audioPlayer?.isPlaying != nil) {
 MPNowPlayingInfoCenter.default().playbackState = .playing
} else {
 MPNowPlayingInfoCenter.default().playbackState = .paused
}

}

override func remoteControlReceived(with event: UIEvent?) {
switch event!.subtype {
 case .remoteControlPlay:
 audioPlayer?.play()
 case .remoteControlPause:
 audioPlayer?.pause()
 case .remoteControlStop:
 audioPlayer?.stop()
 default:
 break
}
}
</code></pre>
</blockquote>
<h2 id="day7-simple-photo-browser">day7: Simple Photo Browser</h2>
<ul>
<li>
<p>UIScrollView使用</p>
<ul>
<li>
<p>使用缩放：设置**<code>maximumZoomScale</code><strong>和</strong><code>minimumZoomScale</code><strong>,实现委托方法</strong><code>ViewForZooming</code>**</p>
<blockquote>
<pre><code class="language-swift">var scrollView:UIScrollView!
scrollView = UIScrollView(frame: self.view.frame)
scrollView.maximumZoomScale = 6.0
scrollView.minimumZoomScale = 1.0
scrollView.backgroundColor = .black
scrollView.contentSize = imageView.bounds.size
scrollView.delegate = self
self.view.addSubview(scrollView)

//MARK: - UIScrollViewDelegate
func viewForZooming(in scrollView: UIScrollView) -&gt; UIView? {
return imageView
}
</code></pre>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="day8-color-gradient">day8: Color Gradient</h2>
<ul>
<li>
<p>CAGradientLayer 渐变层的使用</p>
<ul>
<li><strong>frame</strong>,<strong>colors</strong>...</li>
<li><strong><code>self.view.layer.addsublayer()</code></strong></li>
<li>colors 可用**[CGColor]**数组进行赋值</li>
</ul>
<blockquote>
<pre><code class="language-swift">var grandientLayer:CAGradientLayer!
var colorSets = [[CGColor]]()
var currentColorSet:Int!
func createGradientLayer() {
grandientLayer = CAGradientLayer()
grandientLayer.frame = self.view.bounds
//set gradient color
grandientLayer.colors = colorSets[currentColorSet]
//将grandientLayer作为子layer加到主layer上
self.view.layer.addSublayer(grandientLayer)
}
</code></pre>
</blockquote>
</li>
<li>
<p>Gesture操作之<strong>PanGestureRecognizer</strong>：“滑动”手势，可以识别拖拽或移动动作</p>
<ul>
<li>
<p>初始化UIPanGestureRecognizer</p>
<pre><code class="language-swift">let panGestureRecognizer = UIPanGestureRecognizer(target: self, action: #selector(handlePanGesture(sender:)))
</code></pre>
</li>
<li>
<p>将手势添加到视图上</p>
<pre><code class="language-swift">self.view.addGestureRecogizer(panGestureRecognizer)
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="day9-swipeable-cell">day9: Swipeable Cell</h2>
<ul>
<li>
<p>UItableView使用</p>
<ul>
<li>
<p>**<code>UIContextualAction</code>**的闭包用法</p>
<p><strong>https://www.jianshu.com/p/847deff29f24</strong></p>
<p><strong>https://www.jianshu.com/p/14d778afeefc</strong></p>
</li>
</ul>
<pre><code class="language-swift">//MARK: - UITableViewDataSource
func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int
{
  //返回每个section中的行数
}
//Asks the data source for a cell to insert in a particular location of the table view.
func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
  // cell的初始化与复用，返回cell
}

//MARK: - UITableViewDelegate
//从尾部开始向左滑动cell
func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? {
  //Returns the swipe actions to display on the trailing edge of the row.
  let likeAction = UIContextualAction(style: .normal, title: &quot;👍&quot;) { (action, view, finished) in
            self.actionController.message = &quot;Thanks for your Love 😸&quot;
            self.showAlertController()
            finished(true)
        }
        likeAction.backgroundColor = .white
        
        let disLikeAction = UIContextualAction(style: .normal, title: &quot;👎&quot;) { (action, view, finished) in
            self.actionController.message = &quot;Tell me Why!!!😤&quot;
            self.showAlertController()
            finished(true)
        }
        disLikeAction.backgroundColor = .white
        
        let unknowAction = UIContextualAction(style: .destructive, title: &quot;🖖&quot;) { (action, view, finished) in
            self.actionController.message = &quot;What do you mean? 🤔&quot;
            self.showAlertController()
            finished(true)
        }
        unknowAction.backgroundColor = .white
        //action从右向左的顺序添加
        return .init(actions: [likeAction, disLikeAction , unknowAction])
}
</code></pre>
</li>
<li>
<p>**<code>UIAlertController</code>**的使用</p>
<pre><code class="language-swift">private var actionController: UIAlertController!
//init alertController
actionController = UIAlertController(title: &quot;alert&quot;, message: &quot;&quot;, preferredStyle: .alert)
//...
self.actionController.message = &quot;123&quot;
present(actionController, animated: true) {
  let dismissTimer = Timer.sheduledTimer(withTimeInterval: 2.0, repeats: false) {
    (timer) in 
    	self.actionController.dismiss(animate: true, completion: nil)
  }
  RunLoop.main.add(dismissTimer, forMode: .comoon)
}

</code></pre>
</li>
<li>
<p><strong><code>UIView动画使用</code></strong></p>
<pre><code class="language-swift">//cell的显示动画
let cells = tableView.visibleCells
let tableHeight:CGFloat = tableView.bounds.size.height
for (index, cell) in cells.enumerated() {
  cell.frame.origin.y = tableHeight
  UIView.animate(withDuration: 1.0, delay: 0.04 * Double(index), usingSpringWithDamping: 0.8, initialSpringVelocity: 0, options: [], animations: {
    cell.frame.origin.y = 0
  }, completion: nil)
}
</code></pre>
</li>
</ul>
<h2 id="day10-stretchy-header">day10 Stretchy Header</h2>
<ul>
<li>
<p>UIScrollViewDelegate使用</p>
<pre><code class="language-swift">//MARK: - UIScrollViewDelegate
func scrollViewDidScroll(_ scrollView: UIScrollView) {
  let offsetY = scrollView.contentOffset.y
  let maxOffsetY = tableView.frame.height
  let validateOffsetY = -offsetY / maxOffsetY
  let scaleFactor = 1 + validateOffsetY
  bannerImgView.transform = CGAffineTransform(scaleX: scaleFactor, y: scaleFactor)

}
</code></pre>
</li>
</ul>
<h2 id="day11-gradienttableview">day11 GradientTableView</h2>
<ul>
<li>
<p>UITableView的渐变层</p>
<pre><code class="language-swift">func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
  let cell = UITableViewCell(style: .default, reuseIdentifier: &quot;reuseId&quot;)
  cell.textLabel?.text = self.dataSource[indexPath.row]
  cell.textLabel?.textColor = .white
  cell.selectionStyle = .none

  //cell -&gt; bgView -&gt; gradientLayer, move bgView back to the cell
  let bgview = UIView(frame: CGRect(x: 0, y: 0, width: self.view.frame.width, height: self.cellHeight))
  let gradientLayer = CAGradientLayer()
  gradientLayer.frame = bgview.frame

  let lowerColor:CGColor = UIColor(red: 1.0, green: (CGFloat(indexPath.row * 2) * self.colorRatio)/255.0, blue: (CGFloat(indexPath.row * 2) * self.colorRatio)/255.0, alpha: 1).cgColor
  let upperColor:CGColor = UIColor(red: 1.0, green: (CGFloat(indexPath.row * 2) * self.colorRatio + self.colorRatio)/255.0, blue: (CGFloat(indexPath.row * 2) * self.colorRatio + self.colorRatio)/255.0, alpha: 1).cgColor

  gradientLayer.colors = [lowerColor, upperColor]
  bgview.layer.addSublayer(gradientLayer)
  cell.insertSubview(bgview, belowSubview: cell.contentView)

  /* equal to below
  cell.addSubview(bgview)
  cell.sendSubviewToBack(bgview)
  */

  return cell
}
</code></pre>
</li>
</ul>
<h2 id="day12-emoji-slot-machine">day12 Emoji Slot Machine</h2>
<ul>
<li>
<p><strong>UIPickerView</strong>的使用</p>
<ul>
<li>初始化</li>
</ul>
<blockquote>
<pre><code class="language-swift">slotMachine = UIPickerView(frame: CGRect(x: 0, y: 0, width: self.view.frame.width, height: 220))
self.view.addSubview(slotMachine)
slotMachine.dataSource = self
slotMachine.delegate = self
slotMachine.center.x = self.view.center.x
slotMachine.center.y = self.view.center.y - 50

slotMachine.selectRow(Int(arc4random())%(emojiArray.count), inComponent: 0, animated: false)
slotMachine.selectRow(Int(arc4random())%(emojiArray.count), inComponent: 1, animated: false)
slotMachine.selectRow(Int(arc4random())%(emojiArray.count), inComponent: 2, animated: false)
</code></pre>
</blockquote>
<ul>
<li>
<p><strong>UIPickerViewDataSource</strong>相关</p>
<blockquote>
<pre><code class="language-swift">func numberOfComponents(in pickerView: UIPickerView) -&gt; Int {
return 3
}

func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -&gt; Int {
return emojiArray.count
}
</code></pre>
</blockquote>
</li>
<li>
<p><strong>UIPickerViewDelegate</strong>相关</p>
<blockquote>
<pre><code class="language-swift">func pickerView(_ pickerView: UIPickerView, rowHeightForComponent component: Int) -&gt; CGFloat {
return 90
}

func pickerView(_ pickerView: UIPickerView, viewForRow row: Int, forComponent component: Int, reusing view: UIView?) -&gt; UIView {
let pickerLabel = UILabel()
pickerLabel.text = emojiArray[row]
pickerLabel.textAlignment = .center
pickerLabel.font = .systemFont(ofSize: 60)
return pickerLabel
}
</code></pre>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="day13-loginanimation">day13 LoginAnimation</h2>
<ul>
<li>
<p>UINavigationController的使用</p>
<pre><code class="language-swift">//Pushes a view controller onto the receiver’s stack and updates the display.
let loginVC = LoginViewController()
self.navigationController?.pushViewController(loginVC, animated: false)

//Pops the top view controller from the navigation stack and updates the display.
self.navigationController?.popViewController(animated: true)
</code></pre>
</li>
<li>
<p>UIView.animate动画效果</p>
<pre><code class="language-swift">//初始状态
self.view.alpha = 0
let userNameInputField = UITextField(frame: CGRect(x: -270, y: 50, width: 270, height: 40))
let pswInputField = UITextField(frame: CGRect(x: -270, y: 100, width: 270, height: 40))
let loginButton = UIButton(frame: CGRect(x: -125, y: 160, width: 125, height: 40))
//动画效果
UIView.animate(withDuration: 0.5) {
  self.view.alpha = 1
}

UIView.animate(withDuration: 0.5, delay: 0.6, usingSpringWithDamping: 0.9, initialSpringVelocity: 2, options: .allowAnimatedContent, animations: {
  userNameInputField.center.x = self.view.center.x
}, completion: nil)

UIView.animate(withDuration: 0.5, delay: 0.8, usingSpringWithDamping: 0.9, initialSpringVelocity: 2, options: .allowAnimatedContent, animations: {
  pswInputField.center.x = self.view.center.x
}, completion: nil)

UIView.animate(withDuration: 0.5, delay: 1, options: .curveEaseIn,animations: {
  loginButton.center.x = self.view.center.x
}) { (isComplete) in
    // usingSpringWithDamping: 0-1, the less the more exaggerate
    // initialSpringVelocity: the bigger the faster init speed
    UIView.animate(withDuration: 1, delay: 0.5, usingSpringWithDamping: 0.1, initialSpringVelocity: 2, options:.allowAnimatedContent, animations: {
      loginButton.frame.size.width = 180
      loginButton.center.x = self.view.center.x
    }, completion: nil)
   }
</code></pre>
</li>
</ul>
<h2 id="day14-spotlight-search">day14 Spotlight Search</h2>
<ol>
<li>
<p>CSSearchableItemAttributeSet使用</p>
<pre><code class="language-swift">//Spotlight 搜索配置
let attributSet = CSSearchableItemAttributeSet(itemContentType: &quot;test&quot;)
attributSet.title = itemDic[&quot;name&quot;] as? String
attributSet.contentDescription = itemDic[&quot;description&quot;] as? String
let imageData = (itemDic[&quot;cover&quot;] as? UIImage)!.jpegData(compressionQuality: 0.7)
attributSet.thumbnailData = imageData

let searchItem = CSSearchableItem(uniqueIdentifier: &quot;\(indexPath.row)&quot;, domainIdentifier: &quot;nimomeng&quot;, attributeSet: attributSet)
let tempItems = [searchItem]
CSSearchableIndex.default().indexSearchableItems(tempItems) { (error) in
                                                            }

//AppDelegate.swift
public let notificationName = NSNotification.Name.init(&quot;receivedIdFromSpotlightSearch&quot;)

//？？测试不调用
//应用程序在收到与用户活动相关的数据时调用此方法。 例如，当用户使用“越区切换”从其他设备转移活动时。
func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -&gt; Void) -&gt; Bool {

  if userActivity.activityType == CSSearchableItemActionType {
    if let identifier = userActivity.userInfo?[CSSearchableItemActivityIdentifier] as? String {
      NotificationCenter.default.post(name: notificationName, object: self, userInfo: [&quot;id&quot;: identifier])
    }
  }
  return true
}

//ViewController.swift 
 @objc func receivedNotification(sender: Notification) {
        let userInfo = sender.userInfo
        let index = Int(userInfo?[&quot;id&quot;] as! String)
        let itemDic = dataSource[index!]
        let detailVC = DetailViewController.init(with: itemDic)
        
        self.navigationController?.pushViewController(detailVC, animated: true)
    
    }
</code></pre>
</li>
</ol>
<h2 id="day15-today-widget">day15 Today Widget</h2>
<h3 id="1-today-widget的建立">1. Today Widget的建立</h3>
<blockquote>
<pre><code class="language-swift">//File &gt; New &gt; Target &gt; Applicaion Extension -&gt; Today Extension
//target &gt; capabilities &gt; App Group -&gt; open
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/Luolijie97/Pic_PicGo/master/img/image-20191122105321030.png" alt="" loading="lazy"></figure>
</blockquote>
<h3 id="2-userdefault的使用">2. UserDefault的使用</h3>
<blockquote>
<pre><code class="language-swift">//默认UserDefaults
let defaults = UserDefaults.standard
defaults.set(123, forKey: &quot;defaultKey&quot;)
defaults.integer(forKey: &quot;defaultKey&quot;)

//自定义UserDefaults
let userDefault = UserDefaults(suiteName: &quot;group.llj.watchDemo&quot;)
userDefault?.set(self.labelNumber, forKey: &quot;lefttime&quot;)
userDefault?.removeObject(forKey: &quot;lefttime&quot;)
</code></pre>
</blockquote>
]]></content>
    </entry>
</feed>